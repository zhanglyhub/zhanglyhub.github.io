[{"title":"Bfs For Path","url":"/2025/06/15/m/","content":"\n[KuPellaKeS - UVA 10968 - Virtual Judge](https://vjudge.net/problem/UVA-10968)\n\n_ _Wa___WA_Wa but Ac.....\n\n 被输入输出坑了，...................无语，\n\n本题我刚开始想的时候是维护用并查集维护冗余边，............................不会这么简单吧....好吧真不是这么简单，我一开始也没想到是最短路维护路径信息，看大佬题解才后知后觉，题目问删除一些奇数度点的边，使剩余的点度全为偶数，所给点中最多只有两个奇数度的点，我们可以分类讨论一下：\n\n1）：如果没有奇数度的点，$ans=0$不需要删\n\n2）：如果点度数为$0,1$无解，题目说不能出现度为$0$的点\n\n3）：我们拿到两个奇点的信息，求两个奇点之间的最短路即可（其中不能经过度为2的点）我们想将一个奇点变为偶点，必然会将她邻居的一个点变为奇点，如果隔壁是度为$2$的点就断了，显然是不对的，图是联通的，根据传递性，\"奇 + 奇 = 偶\"，一路传递到另一个奇点，所以只要维护最短路即可。\n\n```cpp\n#include <bits/stdc++.h>\n#define inf 1 << 30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define st first\n#define ed second\nusing namespace std;\n\n\n\nusing ll = long long;\nusing ult = unordered_set<ll>;\nusing ust = unordered_set<int>;\nusing vt = vector<int>;\nusing pii = pair<int, int>;\nusing vpi = vector<pii>;\nusing ll = long long;\nusing pis = pair<int, string>;\nusing mis = unordered_map<int, string>;\nusing mii = unordered_map<int, int>;\nconst int N = 1005;\nint n, m, dis[N], s[N];\nvt g[N];\nvt odd;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    for(;cin >> n >> m && (n || m);) {\n        odd.clear();\n        mem(s, 0);\n        for(int i = 1; i <= n; i++) g[i].clear();\n        for(int i = 1; i <= n; i++) dis[i] = inf;\n        for(int i = 1; i <= m; i++) {\n            int a, b;\n            cin >> a >> b;\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        bool early = 0;\n        for(int i = 1; i <= n; i++) {\n            s[i] = g[i].size(); \n            if(s[i] == 1 || s[i] == 0) {cout << \"Poor Koorosh\" << endl; early = 1;break;}\n            if(s[i] & 1) odd.push_back(i);\n        }\n        if(early) continue;\n        if(odd.size() == 0) {cout << 0 << endl; continue;}\n        bool flag = 0;\n        queue<int> q;\n        q.push(odd[0]);\n        dis[odd[0]] = 0;\n        while(!q.empty()) {\n            int u = q.front();\n            q.pop();\n            if(u == odd[1]) {\n                flag = 1;\n                break;\n            }\n            for(auto v : g[u]) {\n                if(s[v] == 2) continue;\n                if(dis[v] != inf) continue;\n                if(dis[v] > dis[u] + 1) {\n                    dis[v] = dis[u] + 1;\n                    q.push(v);\n                } \n            }\n        }\n        if(flag) cout << dis[odd[1]] << endl;\n        else cout << \"Poor Koorosh\" << endl;\n    }\n    return 0;\n}\n```\n\n\n","tags":["-BFS"],"categories":["Algorithm"]},{"title":"Bfs Status Message","url":"/2025/06/13/e/","content":"\nhttps://codeforces.com/contest/59/problem/E\n\n经典的$bfs$状态信息的维护，我刚开始想成了$dag$拓扑排序生成所有最短路，显然这样是不行的，在任意一个位置我们要维护三个信息，$pre,cur,nxt$三个状态，所以的大体思路确定了使用$bfs$，那么如何实现呢？开始我维护了一个三维$dis$数组，然而这样必然炸内存，在题目所给的这个数据量下，我们要开$\\prod_{i=1}^33000\\times4$字节大小的数组也就是大概$100GB$显然是不合理的，如何高效去维护三个状态呢？我们可以使用数组来维护$pre->cur$的路径信息，用set来维护$cur->nxt$的所有信息，这样我们不仅高效的减少了内存消耗，同时，在$O(logN)$的时间内实现快速查找。\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define st first\n#define ed second\nusing namespace std;\n\n\nusing vt = vector<int>;\nusing pii = pair<int, int>;\nusing vpi = vector<pii>;\nusing ll = long long;\nconst int N = 3005;\nconst int K = 1e5 + 5;\nstruct node {int last, cur, nxt, step;};\nint n, m, k, dis[N][N], pa[N][N];\nvt g[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= m; i++) {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    vector<set<int>> p[N];\n    for(int i = 0; i <= n; i++) p[i].resize(n + 1);\n    for(int i = 1; i <= k; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        p[a][b].insert(c);\n    }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++) {\n            dis[i][j] = inf;\n            pa[i][j] = 0;\n        }\n    }\n    queue<pii> q;\n    for(auto v : g[1]) {\n        q.push({v, 1});\n        pa[v][1] = 0;\n        dis[v][1] = 1;\n    }\n    //clog << \"eror\" << endl;\n    int mn = inf;\n    int pre_n = 0;\n    while(!q.empty()) {\n        int sz  = q.size();\n        for(int i = 1; i <= sz; i++) {\n            auto u = q.front();\n            int cur = u.st;\n            int pre = u.ed;\n            q.pop();\n            if(cur == n) {\n                if(dis[cur][pre] < mn) {\n                    mn = dis[cur][pre];\n                    pre_n = pre;\n                }\n            }\n            if(dis[cur][pre] > mn) continue;\n            for(auto x : g[cur]) {\n                if(p[pre][cur].count(x)) continue;\n                if(dis[x][cur] > dis[cur][pre] + 1) {\n                    dis[x][cur] = dis[cur][pre] + 1;\n                    pa[x][cur] = pre;\n                    q.push({x, cur});\n                }\n            }\n        }\n    }\n    if(mn == inf) cout << -1 << endl;\n    else {\n        cout << mn << endl;\n        vt path;\n        int cur = n;\n        int pre = pre_n;\n        while(cur) {\n            path.push_back(cur);\n            if(cur == 1) break;\n            int tmp = pa[cur][pre];\n            cur = pre;\n            pre = tmp;\n        }\n        reverse(path.begin(), path.end());\n        for(int v : path) cout << v << ' ';\n    }\n    return 0;\n}\n```\n\n上面的$code$会在$test8$是炸内存，为什么呢？分析数据结构发现，我们预先开辟了空间，但真的有必要为每一个三元组，开辟空间吗？不是的，只需要在禁忌路上动态拓展即可。\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define st first\n#define ed second\nusing namespace std;\n\n\nusing vt = vector<int>;\nusing pii = pair<int, int>;\nusing vpi = vector<pii>;\nusing ll = long long;\nconst int N = 3005;\nconst int K = 1e5 + 5;\nstruct node {int last, cur, nxt, step;};\nint n, m, k, dis[N][N], pa[N][N];\nvt g[N];\nvt path(N);\nvector<unordered_map<int, set<int>>> p(N);\nqueue<pii> q;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= m; i++) {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    for(int i = 1; i <= k; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        p[a][b].insert(c); \n    }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++) {\n            dis[i][j] = inf;\n            pa[i][j] = 0;\n        }\n    }\n    for(auto v : g[1]) {\n        q.push({v, 1});\n        pa[v][1] = 0;\n        dis[v][1] = 1;\n    }\n    //clog << \"eror\" << endl;\n    int mn = inf;\n    int pre_n = 0;\n    while(!q.empty()) {\n        int sz  = q.size();\n        for(int i = 1; i <= sz; i++) {\n            auto u = q.front();\n            int cur = u.st;\n            int pre = u.ed;\n            q.pop();\n            if(cur == n) {\n                if(dis[cur][pre] < mn) {\n                    mn = dis[cur][pre];\n                    pre_n = pre;\n                }\n            }\n            if(dis[cur][pre] > mn) continue;\n            for(auto x : g[cur]) {\n                if(p[pre][cur].count(x)) continue;\n                if(dis[x][cur] > dis[cur][pre] + 1) {\n                    dis[x][cur] = dis[cur][pre] + 1;\n                    pa[x][cur] = pre;\n                    q.push({x, cur});\n                }\n            }\n        }\n    }\n    if(mn == inf) cout << -1 << endl;\n    else {\n        cout << mn << endl;\n        path.clear();\n        int cur = n;\n        int pre = pre_n;\n        while(cur) {\n            path.push_back(cur);\n            if(cur == 1) break;\n            int tmp = pa[cur][pre];\n            cur = pre;\n            pre = tmp;\n        }\n        reverse(path.begin(), path.end());\n        for(int v : path) cout << v << ' ';\n    }\n    return 0;\n}\n```\n\n这样的内存消耗一般也就几十$MB$，远远少于题目限制。\n\n\n\n\n\nhttps://www.spoj.com/problems/MULTII/\n\n这也是一道$bfs$状态类型题目，题目要求找到给定正整数$n$的最小倍数不能出现给定的整数$m$，像这类倍数问题，我们定义状态一般为当前数$cur \\mod n$的余数是否为$0$如果为$0$我们就找到的一个数是$n$的倍数。假设当前数是$cur$有:\n$cur\\mod n = p$\n\n$cur / n = a$所以$cur = a * n + p$\n\n我们尝试在$cur$后加一个数$d$\n\n有$nxt = cur * 10 + d$\n\n而$nxt_p = (cur * 10 + d) \\mod n$\n\n依据同余原理：\n$nxt_p = (cur_p * 10  +d) \\mod n$\n\n所以只要我们知道当前状态的余数我们总能通过加$d$的方式来得到下一个余数，所以我们只需要用队列维护余数的状态即可。\n\n```cpp\n#include <bits/stdc++.h>\n#define inf 1 << 30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define st first\n#define ed second\nusing namespace std;\n\n\nusing ll = long long;\nusing ult = unordered_set<ll>;\nusing ust = unordered_set<int>;\nusing vt = vector<int>;\nusing pii = pair<int, int>;\nusing vpi = vector<pii>;\nusing ll = long long;\nconst int N = 10005;\nll n, m, cur, vis[N], pa[N], t; //因为要恢复路径，所以要vis标记一访问的余数\nchar dis[N]; //pa数组：我当前节点是由那一个节点拓展来的，dis数组记录路径\nult s; //注意bfs维护的是每一位数字，而层数就是当前来到的位数\nint main() {\n    for(t = 1; cin >> n >> m; t++) {\n        mem(vis, 0);\n        mem(dis, 0);\n        mem(pa, -1);\n        s.clear();\n        for(int i = 1; i <= m; i++) {\n            int a;\n            cin >> a;\n            s.insert(a);\n        }\n        queue<int> q;\n            for(int d = 1; d <= 9; d++) {\n                if(s.count(d)) continue;\n                int c = d % n;\n                if(!vis[c]) {\n                vis[c] = 1;\n                pa[c] = -2;//-2 表示虚拟父节点节点\n                dis[c] = (char)(d + '0');\n                q.push(c);\n            }\n        }\n        bool flag = 0;\n        string ans = \"\";\n        while(!q.empty()) {\n            int u = q.front();\n            q.pop();\n            if(u == 0) {\n                flag = 1;\n                int v = pa[u];\n                string tmp = \"\";\n                tmp += dis[u];\n                ans += to_string(v);\n                for(; v != -2; v = pa[v]) {\n                    tmp += dis[v];\n                    //cerr << dis[v] << ' ';\n                }\n                //ans += pa[v];\n                //cerr << pa[v] << ' ' << ans << endl;\n                reverse(tmp.begin(), tmp.end());\n                ans = tmp;\n                //cerr << ans;\n                break;\n            }\n            for(int d = 0; d <= 9; d++) {\n                if(s.count(d)) continue;\n                int nxt = (u * 10 + d) % n;\n                if(!vis[nxt]) {\n                    vis[nxt] = 1;\n                    pa[nxt] = u;\n                    dis[nxt] = (char)(d + '0');\n                    q.push(nxt);\n                }\n            }\n        }\n        if(flag) cout << \"Case \" << t << \": \"<< ans << endl;\n        else cout << \"Case \" << t << \": \"<< -1 << endl;\n    }\n}\n```\n\n这是一种很妙的写法，如果我们暴力生成所有倍数，时间空间都会爆炸，而这种基于状态去枚举每一位余数的方法，则有效优化，时间复杂度$O(N)$，空间复杂度$O(N)$\n\n\n","tags":["-BFS"],"categories":["Algorithm"]},{"title":"Unsolve","url":"/2025/06/12/d/","content":"\n```cpp\n\nhttps://www.spoj.com/problems/ADV04F1/\n\nhttps://www.spoj.com/problems/INVESORT/\n\nhttps://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2387\n```\n\n$TLE$大满贯QAQ\n","tags":["-BFS"],"categories":["Algorithm"]},{"title":"Codeforces Round 1003 Div4","url":"/2025/06/12/Codeforces Round 1003 Div4/","content":"\n[Problem - A - Codeforces](https://codeforces.com/contest/2065/problem/A)\n\n模拟\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring s;\nint main() {\n    cin >> n;\n    for(int i = 1; i <= n; i++) {\n        cin >> s;\n        int n = s.size();\n        cout << (s.substr(0, n - 2) + \"i\") << endl;\n    }\n    return 0;\n}\n```\n\n[Problem - B - Codeforces](https://codeforces.com/contest/2065/problem/B)\n\n消消乐\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring s;\nvoid f() {\n    cin >> s;\n    int p1 = 0, p2 = p1 + 1;\n    while(p2 < s.size()) {\n        if(s[p1] == s[p2]) {\n            cout << 1 << endl;\n            return;\n        }\n        p1++; p2++;\n    } \n    cout << s.size() << endl;\n}\nint main() {\n    cin >> n;\n    while(n--) f();\n    return 0;\n}\n```\n\n[Problem - C1 - Codeforces](https://codeforces.com/contest/2065/problem/C1)\n\nc题卡了很久，主要是题意没读懂，搞清楚提议后，很容易想到二分\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\nusing namespace std;\n\nconst int N = 2e5 + 5;\nint t, n, m, a[N], b[N];\nvector<int> c;\nvoid f() {\n    memset(a, 0, sizeof(a));\n    memset(b, 0, sizeof(b));\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for(int i = 1; i <= m; i++) {\n        cin >> b[i];\n    }\n    int mn = -inf;\n    sort(b + 1, b + m + 1);\n    for(int i = 1; i <= n; i++) {\n        int cur = inf;\n       if(a[i] >= mn) cur = min(a[i], cur);\n        auto x = lower_bound(b + 1, b + 1 + m, mn + a[i]);\n        if(x != b + m + 1) {\n            //pre = mn;\n            cur = min(cur, *x - a[i]);\n            //cerr << pre << endl;\n        }\n        if(cur == inf) {\n            cout << \"NO\" << endl;\n            return;\n        } else {\n            mn = cur;\n        }\n    }\n    cout << \"YES\" << endl;\n}\nint main() {\n    cin >> t;\n    while(t--) f();\n}\n```\n\n这里显然我们是不能预处理生成$b[j] - a[i]$数组的，只能在线做，设前一个数的最大值为$cur$，既然单调增，所以就有$b[j] - a[i] >= cur$，所以$b[j] >= cur + a[i]$，我们只需要在$b$中查找大于$cur + a[i]$的最小数，排序二分即可。\n\n\n\n\n","categories":["VP"]},{"title":"Key And Lock","url":"/2025/06/10/Key-And-Lock/","content":"\nLeetcode-879\n\nhttps://leetcode.cn/problems/shortest-path-to-get-all-keys/description/\n\n与上面类似，$bfs$维护一个数组$vis$记录访问的节点，和钥匙的状态。\n\n# ***ACcode***\n\n```cpp\n    #include<bits/stdc++.h>\n    #define inf 1 << 30\n    using namespace std;\n    \n    class Solution {\n    public:\n        int shortestPathAllKeys(vector<string>& g) {\n            int n = g.size(), m = g[0].size();\n            int x0 = 0, y0 = 0, k = 0;\n            int vis[31][31][1 << 7] = {};\n            int dx[] = {0, 0, -1, 1};\n            int dy[] = {-1, 1, 0, 0};\n            struct node {int x, y, w, s;};\n            queue<node> q;\n            for(int i = 0; i < n; i++) {\n                for(int j = 0; j < m; j++) {\n                    if(g[i][j] == '@') {\n                        x0 = i, y0 = j;\n                    }\n                    if(g[i][j] >= 'a' && g[i][j] <= 'z') {\n                        k++;\n                    }\n                }\n            }\n            vis[x0][y0][0] = 1;\n            q.push({x0, y0, 0, 0});\n            while(!q.empty()) {\n                auto[x, y, w, s] = q.front();\n                q.pop();\n                //cout << x << ' ' << y << ' ' << w <<' ' << s << endl;\n                //cout << f(w) << ' ';\n                if(f(w) == k) return s;\n                for(int i = 0; i < 4; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if(nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                        if(g[nx][ny] == '#') continue;\n                        if(g[nx][ny] >= 'a' && g[nx][ny] <= 'z') {\n                            int nxt = 1 << (g[nx][ny] - 'a');\n                            if(!vis[nx][ny][w | nxt]) {\n                                vis[nx][ny][w | nxt] = 1;\n                                q.push({nx, ny, w | nxt, s + 1});\n                            }\n                        }\n                        if(g[nx][ny] >= 'A' && g[nx][ny] <= 'Z') {\n                            int nxt = 1 << (g[nx][ny] - 'A');\n                            if((w & nxt) && !vis[nx][ny][w]) {\n                                vis[nx][ny][w] = 1;\n                                q.push({nx, ny, w, s + 1});\n                            } else continue;\n                        }\n                        if((g[nx][ny] == '.' || g[nx][ny] == '@') && !vis[nx][ny][w]) {\n                            q.push({nx, ny, w, s + 1});\n                            vis[nx][ny][w] = 1;\n                        }\n                    }//g[nx][ny] == '@'一定要特判，很坑\n                }\n            }\n            // for(int i = 0; i < n; i++) {\n            //     for(int j = 0; j < n; j++) {\n            //         cout << dis[i][j];\n            //     }\n            //     cout << endl;\n            // }\n            return -1;\n        }\n        int f(int x) {\n            int cnt = 0;\n            while(x) {\n                x &= (x - 1);\n                cnt++;\n            }\n            return cnt;\n        }\n    };\n\n$bfs$版本.........明天完善\n\n    #include<bits/stdc++.h>\n    #define inf 1 << 30\n    using namespace std;\n    \n    const int N = 45;\n    int dx[] = {0, 0, 0, -1, 1};\n    int dy[] = {0, -1, 1, 0, 0};\n    int n, m, s, dis[N][N];\n    char g[N][N], vis[N][N];\n    struct node {int x, y, w;};\n    int main() {\n        cin >> n >> m >> s;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= m; j++) {\n                g[i][j] = 0;\n                vis[i][j] = 0;\n                dis[i][j] = inf;\n            }\n        }\n        deque<node> q;\n        int x0 = 0, y0 = 0, x1 = 0, y1 = 0;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= m; j++) {\n                cin >> g[i][j];\n                if(g[i][j] == '@') {\n                    //cerr << i << ' ' << j << endl;;\n                    q.push_front({i, j, 0});\n                    dis[i][j] = 0;\n                    vis[x0][y0] = 1;\n                }\n                if(g[i][j] == 'x') {\n                    x1 = i, y1 = j;\n                }\n                //cerr << g[i][j] << ' ';\n            }\n            //cerr << endl;\n        }\n        //cerr << x1 << \" \" << y1 << endl;\n        int mn = inf;\n        while(!q.empty()) {\n            int sz = q.size();\n            bool flag = 0;\n            int cur = inf;\n            for(int i = 1; i <= sz; i++) {\n                int x = q.front().x;\n                int y = q.front().y;\n                int w = q.front().w;\n                //cerr << w << endl;\n                q.pop_front();\n                cerr << x << ' ' << y << ' ' <<  w << endl;\n                if(w > dis[x][y]) continue;\n                if(x == x1 && y == y1) {\n                //cerr << x << ' ' << y << endl;\n                //cerr << w << endl;\n                    mn = w;\n                    break;\n                }\n                for(int i = 1; i <= 4; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if(nx <= n && nx >= 1 && ny <= m && ny >= 1) {\n                        if(dis[nx][ny] > dis[x][y] + g[nx][ny] == 's') {\n                            dis[nx][ny] = dis[x][y] + g[nx][ny] == 's';\n                        }\n                        if(g[nx][ny] == 's' && !vis[nx][ny]) {\n                            vis[nx][ny] = 1;\n                            q.push_front({nx, ny, w + 1});\n                        } else if(g[nx][ny] == '.' && !vis[nx][ny]) {\n                            vis[nx][ny] = 1;\n                            q.push_back({nx, ny, w});\n                        } else if(g[nx][ny] == '#')\n                            continue;\n                    }\n                }\n            }\n        }\n        cerr << mn;\n        if((mn != inf) && mn * 2 <= s) cout << \"SUCCESS\" << endl;\n        else cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n```\n\n\n","tags":["-BFS"],"categories":["Algorithm"]},{"title":"Mistakes Book-","url":"/2025/06/10/b/","content":"\n```cpp\n//https://www.spoj.com/problems/ADV04F1/ ---TLE\n#include<bits/stdc++.h>\nusing namespace std;\nusing sta = array<int, 4>;\nusing ll = long long;\n\nconst int n = 20;\nint t, a, b, c, d;\nstruct my_hash {\n    size_t operator() (const sta &x) const {\n        ll hash_val = (ll)x[0] * (n + 1) * (n + 1) * (n + 1) + \n                        (ll)x[1] * (n + 1) * (n + 1) + \n                        (ll)x[2] * (n + 1) +\n                        (ll)x[3];\n            return hash<ll>()(hash_val);\n    }\n};\nint bfs(sta &x, unordered_map<sta, int, my_hash> &dis1, unordered_map<sta, int, my_hash> &dis2, queue<sta> &q) {\n    for(int i = 0; i < x.size(); i++) {\n        int l = x[i] - 1;\n        if(l >= 1) {\n            bool flag = 0;\n            for(int k = 0; k < 4; k++) {\n                if(k != i && x[k] == l) {\n                    flag = 1;\n                    break;\n                }\n            }\n            if(!flag) {\n                sta nxt = x;\n                nxt[i] = l;\n                sort(nxt.begin(), nxt.end());\n                if(dis2.count(nxt)) {\n                    return dis2[nxt] + dis1[x] + 1;\n                }\n                if(dis1.find(nxt) == dis1.end()) {\n                    dis1[nxt] = dis1[x] + 1;\n                    q.push(nxt);\n                }\n            }\n        }\n        int r = x[i] + 1;\n        if(r <= n) {\n            bool flag = 0;\n            for(int k = 0; k < 4; k++) {\n                if(k != i && x[k] == r) {\n                    flag = 1;\n                    break;\n                }\n            }\n            if(!flag) {\n                sta nxt = x;\n                nxt[i] = r;\n                sort(nxt.begin(), nxt.end());\n                if(dis2.count(nxt)) {\n                    return dis2[nxt] + dis1[x] + 1;\n                }\n                if(dis1.find(nxt) == dis1.end()) {\n                    dis1[nxt] = dis1[x] + 1;\n                    q.push(nxt);\n                }\n            }\n        }\n    }\n    for(int i = 0; i < x.size(); i++) {\n        for(int j = 0; j < x.size(); j++) {\n            if(i == j) continue;\n            int op = x[j] * 2 - x[i];\n            if(op >= 1 && op <= n) {\n                bool flag = 0;\n                for(int k = 0; k < 4; k++) {\n                    if(k != i && op == x[k]) {\n                        flag = 1;\n                        break;\n                    }\n                }\n                if(!flag) {\n                    sta nxt = x;\n                    nxt[i] = op;\n                    sort(nxt.begin(), nxt.end());\n                    if(dis2.count(nxt)) {\n                        return dis2[nxt] + dis1[x] + 1;\n                    }\n                    if(dis1.find(nxt) == dis1.end()) {\n                        dis1[nxt] = dis1[x] + 1;\n                        q.push(nxt);\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\nvoid solve() {\n    cin >> a >> b >> c >> d;\n    sta st = {1, 2, 3, 4};\n    sta ed = {a, b, c, d};\n    sort(ed.begin(), ed.end());\n    queue<sta> q1;\n    queue<sta> q2;\n    unordered_map<sta, int, my_hash> dis1, dis2;\n    dis1[st] = 0;\n    dis2[ed] = 0;\n    q1.push(st);\n    q2.push(ed);\n    if(st == ed) {\n        cout << 0 << endl;\n        return;\n    }\n    int res = -1;\n    while(!q1.empty() && !q2.empty()) {\n        // for(int i = 0; i < 4; i++) {\n        //     cout << x[i] << ' ' << y[i] << endl;  \n        //     cout << endl;\n        // }\n        int cur_res;\n        if(q1.size() >= q2.size()) {\n            sta cur = q2.front();\n            q2.pop();\n            cur_res = bfs(cur, dis2, dis1, q2);\n        } else {\n            sta cur = q1.front();\n            q1.pop();\n            cur_res = bfs(cur, dis1, dis2, q1);\n        }\n        if(cur_res != -1) {\n            res = cur_res;\n            break;\n        }\n    }\n    cout << res << endl;\n}\nint main() {\n    cin >> t;\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    while(t--) solve();\n    return 0;\n}\n```\n\n\n\n虽然没有ac这道题，时间卡太紧了，*~~是我菜~~*，但双向搜索的方法还是挺重要的。\n\n具体来说，从起点和终点同时进行$bfs$，当每次拓展队列大小较小的那个，当一个的状态出现在另一个已经访问，则说明我们找到了合法通路。\n\n\n\nhttps://www.spoj.com/problems/INVESORT/\n\n同样是一道双向$bfs$超时\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing sta = array<char, 12>;\n\nstring s1, s2;\nbool bfs(queue<string> &q, unordered_map<string, int> &st1, unordered_map<string, int> &st2, int &ans)\n{\n    for (int i = 1; i <= q.size(); i++)\n    {\n        string s = q.front();\n        q.pop();\n        for (int i = 0; i < s.size(); i++)\n        {\n            for (int j = i + 1; j < s.size(); j++)\n            {\n                string nxt = s;\n                reverse(nxt.begin() + i, nxt.begin() + j + 1);\n                if (st2.count(nxt))\n                {\n                    ans = st1[s] + st2[nxt] + 1;\n                    return 1;\n                }\n                if (st1.find(nxt) == st1.end())\n                {\n                    st1[nxt] = st1[s] + 1;\n                    q.push(nxt);\n                }\n            }\n        }\n    }\n    return 0;\n}\nint main()\n{   \n    while (s1 != \"*\" && s2 != \"*\")\n    {\n        cin >> s1 >> s2;\n        if (s1 == \"*\" && s2 == \"*\")\n            break;\n        if (s1 == s2)\n        {\n            cout << 0 << endl;\n            continue;\n        }\n        string nxt = s1;\n        reverse(nxt.begin(), nxt.end());\n        if (nxt == s2)\n        {\n            cout << 1 << endl;\n            continue;\n        }\n        unordered_map<string, int> st1, st2;\n        queue<string> q1, q2;\n        q1.push(s1);\n        q2.push(s2);\n        st1.insert({s1, 0});\n        st2.insert({s2, 0});\n        int ans = 0;\n        while (!q1.empty() && !q2.empty())\n        {\n            if (q1.size() >= q2.size())\n            {;\n                if (bfs(q2, st2, st1, ans))\n                    break;\n            }\n            else\n            {\n                if (bfs(q1, st1, st2, ans))\n                    break;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n```\n\nhttps://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2387\n\n$bfs$维护模数信息\n\ntle\n\n```cpp\n#include <bits/stdc++.h>\n#define inf 1 << 30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define st first\n#define ed second\nusing namespace std;\n\n\nusing ll = long long;\nusing ult = unordered_set<ll>;\nusing ust = unordered_set<int>;\nusing vt = vector<int>;\nusing pii = pair<int, int>;\nusing vpi = vector<pii>;\nusing ll = long long;\nusing pis = pair<int, string>;\nusing mis = unordered_map<int, string>;\nconst int N = 1e6 + 5;\nint k, a[] = {0, 3, 0}, vis[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    for(;cin >> k;) {\n        mis dis;\n        //for(int i = 0; i <= k; i++) dis[i].clear();\n        queue<pis> q;\n        int p = 3 % k;\n        if(p == 0) dis[0] = \"3\";\n        else {\n            dis[p] = \"3\";\n            q.push({p, \"3\"});\n        }\n        string ans = \"\";\n        while(!q.empty()) {\n            int u = q.front().st;\n            string s = q.front().ed;\n            q.pop();\n            //for(int i = 0 ;i < k; i++) cerr << dis[k] << ' ';\n            if(u == 0) {ans = s; break;}\n            //if(dis[u] < s) continue;\n            //if(s != dis[u]) continue;\n            if(s.back() == '3') {\n                int nxt = (u * 10 + 3) % k;\n                string nxts = s + \"3\";\n                if(nxts > dis[nxt]) {\n                    dis[nxt] = nxts;\n                    q.push({nxt, nxts});\n                }  \n            }\n            int nxt = (u * 10 + 0) % k;\n            string nxts = s + \"0\";\n            if(nxts > dis[nxt]) {\n                dis[nxt] = nxts;\n                q.push({nxt, nxts});\n            }\n        }\n        int cnt0 = 0, cnt3 = 0;\n        //cerr << ans << endl;\n        for(char c : ans) {\n            cnt0 += (c == '0');\n            cnt3 += (c == '3');\n        }\n        cout << ans.size() << ' ' << cnt3 << ' ' << cnt0 << endl;\n    }\n    return 0;\n}\n```\n\n改了一下case3没输出\n\n```cpp\n#include <bits/stdc++.h>\n#define inf 1 << 30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define st first\n#define ed second\nusing namespace std;\n\n\nusing ll = long long;\nusing ult = unordered_set<ll>;\nusing ust = unordered_set<int>;\nusing vt = vector<int>;\nusing pii = pair<int, int>;\nusing vpi = vector<pii>;\nusing ll = long long;\nusing pis = pair<int, string>;\nusing mis = unordered_map<int, string>;\nconst int N = 1e6 + 5;\nint k, vis[N], pa[N];\nchar dis[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    for(;cin >> k;) {\n        queue<int> q;\n        mem(pa, 0);\n        mem(vis, 0);\n        mem(dis, 0);\n        int cc = 3 % k;\n        if(cc == 0) {\n            cout << 3 << endl;\n            break;\n        } else {\n            vis[cc] = 1;\n            dis[cc] = '3';\n            pa[cc] = -1;\n            q.push(cc);\n        }\n        while(!q.empty()) {\n            int m = q.size();\n            for(size_t i = 1; i <= m; i++) {\n                int u = q.front();\n                //cerr << u << ' ';\n                q.pop();\n                vis[u] = 1;\n                cerr << q.empty() << endl;\n                if(u == 0) {\n                    vector<char> l;\n                    for(int v = u; ~v; v = pa[v]) {\n                        l.push_back(dis[v]);\n                    }\n                    //for(int i = 1; i <= k; i++) cerr << pa[i] << ' ';\n                    reverse(l.begin(), l.end());  \n                    for(auto x : l) {\n                        cout << x;\n                    }\n                    cout << endl;\n                    goto h;\n                }\n                if(dis[u] == '3') {\n                    int cur = (u * 10 + 3) % k;\n                    if(vis[cur]) continue;\n                    dis[cur] = '3';\n                    pa[cur] = u;\n                    q.push(cur);\n                }\n                int cur = (u * 10 + 0) % k;\n                if(vis[cur]) continue;\n                dis[cur] = '0';\n                pa[cur] = u;\n                q.push(cur); \n            }\n        }\n        h:\n    }\n    return 0;\n}\n```\n\n\n\n\n\ntle\n\nhttps://www.spoj.com/problems/ADV04F1/\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\n\nusing vt = vector<int>;\nusing pii = pair<int, int>;\nusing vpi = vector<pii>;\nusing ll = long long;\nconst int N = 3005;\nconst int K = 1e5 + 5;\nint n, m, k, a, b, ai, bi, ci, dis1[N], dis2[N], vis1[N], vis2[N], in[N], dis[N], used[N];\nvpi g[N], ee[N];\nvoid bfs(int &dis[], int &vis[], queue<int> &q) {\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for(auto v : g[u]) {\n            if(dis[v] > dis[v] + 1) {\n                dis[v] = dis[u] + 1;\n            }\n        }\n    }\n}\nint main() {\n    cin >> n >> m >> k;\n    for(int i = 1; i <= m; i++) {\n        cin >> a >> b;\n        g[a].push_back({b, 1});\n        g[b].push_back({a, 1});\n    }\n    for(int i = 1; i <= k; i++) {\n        cin >> ai[i] >> bi[i] >> ci[i];\n    }\n    queue<int> q, q2;\n    q1.push(1);\n    q2.push(n);\n    for(int i = 1; i <= n; i++) {\n        dis1[i] = inf;\n        dis2[i] = inf;\n        dis[i] = inf;\n    }\n    mem(vis1, 0);\n    mem(vis2, 0);\n    mem(in, 0);\n    mem(used, 0);\n    dis1[1] = 0;dis2[n] = 0;\n    bfs(dis1, vis1, q1);\n    bfs(dis2, vis2, q2);\n    int ans = 0;\n    for(int i = 1; i <= n; i++) {\n        if(dis1[i] + dis2[i] == dis1[n]) {\n            ee[1].push_back({i, dis1[i]});\n            ee[i].push_back({n, dis2[i]});\n            in[i]++;\n            in[n]++;\n        }\n    }\n    used[1] = 1;\n    dis[1] = 0;\n    vt pa, p;\n    vt l;\n    pa[1] = -1;\n    queue<int> s;\n    for(int i = 1; i <= n; i++) {\n        if(in[i] == 0) q.push(i); \n    }\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for(auto v : ee[u]) {\n            if(dis[v] > dis[u] + 1) {\n                dis[v] = dis[u] + 1;\n            }\n            if(!used[v]) {\n                for(int x = v; ~x; x = pa[x]) {\n                    p.push_back(v);\n                }\n            }\n            if(--in[v] == 0) {\n                q.push(v);\n                l.push_back(v);\n            }\n        }\n    }\n    if(l.size() < n) {\n        cout << -1 << endl;\n    } else {\n        cout << p.size() << endl;\n    }\n    reverse(p.begin(), p.end());\n    for(auto v : p) {\n        cout << v << ' ';\n    }\n    return 0;\n}\n```\n","tags":["-BFS FOR TWO"],"categories":["Algorithm"]},{"title":"BFS","url":"/2025/06/08/bfs/","content":"\n一般都为多源$bfs$，队列实现，每次处理一层(我更喜欢叫它如下弹出行为重复$size$遍)\n\nLeetCode-1162地图分析\n\nhttps://leetcode.cn/problems/as-far-from-land-as-possible/description/\n\n几乎可以说是模板题，要求最远的距离，其实就是在求$bfs$了多少层返回层数即可。\n\n------------------------------------------------------------------------------------------------------------------------------\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int d[] = {-1, 0, 1, 0, -1};//d数组的用法\n        int sea = 0;\n         queue<pair<int, int>> q;\n        bool vis[101][101] = {};\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == 1) {\n                    q.push({i, j});\n                    vis[i][j] = 1;\n                } else {\n                    vis[i][j] = 0;\n                    sea++;\n                }\n            }\n        }\n        if(sea == 0 || sea == n * n) return -1;\n        int level = -1;        //注意level初始化为-1，默认从第0层开始\n        while(!q.empty()) {\n            level++;\n            //cout << level << ' ';\n            int sz = q.size();\n            for(int i = 0; i < sz; i++) {\n                int x = q.front().first;\n                int y = q.front().second;\n                q.pop();\n                for(int i = 0; i < 4; i++) {\n                    int nx = x + d[i];\n                    int ny = y + d[i + 1];\n                    if(nx < n && nx >= 0 && ny >= 0 && ny < n && !vis[nx][ny] && grid[nx][ny] == 0) {\n                        vis[nx][ny] = 1;\n                        //cout << nx << ' ' << ny << endl;\n                        q.push({nx, ny});\n                    }\n                }\n            }\n        }\n        return level;\n    }\n};\n```\n\n\n\nLeetCode-691贴纸拼词\n\nhttps://leetcode.cn/problems/stickers-to-spell-word/description/\n\n这道题有多种解法，动态规划也能解（好吧其实是我没学），$bfs$ 的解法挺妙的，我们可以这样考虑，每次使用这些贴纸可以搞定$target$多少字符，自然智慧，显然字符的顺序是不影响答案的，所以我们可以先排序，注意这里的剪枝，考虑我们迟早要干掉首字符的，莫不如顶着首字符先干掉，再去干掉后面的字符，接下来就是$bfs\\:+del$函数的设计，具体看$code$\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minStickers(vector<string>& stickers, string target) {\n        int n = stickers.size();\n        sort(target.begin(), target.end());\n        vector<string> g[401];\n        for(auto str : stickers) {\n            sort(str.begin(), str.end());\n            for(int i = 0; i < str.size(); i++) {\n                if(i == 0 || str[i] != str[i - 1]) {\n                    g[str[i] - 'a'].push_back(str);//避免重复加入\n                }\n            }\n        }\n        unordered_map<string, bool> vis;\n        queue<string> q;\n        vis[target] = 1;\n        q.push(target);\n        int level = 1;\n        while(!q.empty()) {\n            int sz= q.size();\n            for(int i = 0; i < sz; i++) {\n                string cur = q.front();\n                q.pop();\n                for(string s : g[cur[0] - 'a']) {\n                    string nxt = del(cur, s);\n                    sort(nxt.begin(), nxt.end());\n                    //cout << nxt << ' ';\n                    if(nxt == \"\") return level;\n                    else if(!vis[nxt]) {\n                        vis[nxt] = 1;\n                        q.push(nxt);\n                    }\n                }\n            }\n            level++;\n        }\n        return -1;\n    }\n    string del(string cur, string s) {\n        vector<int> cnt1 (26, 0);//词频统计\n        vector<int> cnt2 (26, 0);\n        string ans = \"\";\n        for(int i = 0; i < cur.size(); i++) {\n            cnt1[cur[i] - 'a']++;\n        }\n        for(int i = 0; i < s.size(); i++) {\n            cnt2[s[i] - 'a']++;\n        }\n        for(int i = 0; i < 26; i++ ) {\n            int times = cnt1[i] - cnt2[i];\n            if(times > 0) {\n                ans += string(times, i + 'a');\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n# bfs变种之01bfs\n\n顾名思义，就是图中所有边的权值只有01两种，01bfs我们使用双端队列，将权值为1的从尾部加入，权值为0的从头部加入。\n\nLeetCode-2290\n\nhttps://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/\n\n板题\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCost(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<int> dis(n * m, inf);\n        dis[0] = 0;\n        int dx[] = {0, -1, 0, 1, 0};\n        int dy[] = {0, 0, 1, 0, -1};\n        deque<pair<int, int>> dq;\n        dq.push_front({0, 0});\n        while(!dq.empty()) {\n            int x = dq.front().first;\n            int y = dq.front().second;\n            int idx = x * m + y;\n            for(int i = 1; i <= 4; i++) {\n                int nx = x + d[i];\n                int ny = y + d[i];\n                int nidx = x * m + y;\n                if(nx < n && ny < m && nx >= 0 && ny >= 0)  {\n                    int w = grid[nx][ny] == i;\n                    if(dis[nidx] > dis[idx] + w) {\n                        dis[nidx] = dis[idx] + w;\n                        if(w == 0) dq.push_front({nx, ny};)\n                        else dq.push_back({nx, ny});\n                    }\n                }\n            }\n        }\n        return dis[n * m - 1];\n    }\n};\n```\n\n这里有个技巧建立二维到一维的映射公式：$x * m + y$\n\n\n\nLeetCode-1368\n\nhttps://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description/\n\n其实也是简单01bfs啦，要看明白这个转化，箭头和我要去的方向一样就是0，否则就是1\n\n***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCost(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<int> dis(n * m, inf);\n        dis[0] = 0;\n        int dx[] = {0, 0, 0, 1, -1};\n        int dy[] = {0, 1, -1, 0, 0};\n        deque<pair<int, int>> dq;\n        //dq.clear();\n        dq.push_front({0, 0});\n        while(!dq.empty()) {\n            int x = dq.front().first;\n            int y = dq.front().second;\n            dq.pop_front();\n            int idx = x * m + y;\n            if (idx == n * m - 1) return dis[idx];//安全返回\n            for(int i = 1; i <= 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];;\n                int nidx = nx * m + ny;\n                if(nx < n && ny < m && nx >= 0 && ny >= 0)  {\n                    int w = (grid[x][y] == i) ? 0 : 1;\n                    if(dis[nidx] > dis[idx] + w) {\n                        dis[nidx] = dis[idx] + w;//这里要注意提前返回的时机不能在这里，因为只有当前节点\"真正\"从队列中弹出时才能返回（更新）\n                        if(w == 0) dq.push_front({nx, ny});\n                        else dq.push_back({nx, ny});\n                    }\n                }\n            }\n        }\n        // for(int i = 0; i < dis.size(); i++) {\n        //     cout << dis[i] << ' ';\n        // }\n        return dis[n * m - 1];\n    }\n};\n```\n\nLeetCode-接雨水II\n\nhttps://leetcode.cn/problems/trapping-rain-water-ii/submissions/634317688/\n\n越界也是没谁了，方向数组写错也是没谁了。悼念........................................\n\n经典的堆和$bfs$的结合，和一维接雨水类似，首先，考虑外围一层，显然不能接雨水，而我内层势必依赖于外层的最小高度所以有：$max_{inh}<=min_{outh}$，不妨拓展开来，对于每一个柱子，考虑四个方向必然也满足这个条件，所以我们可以用堆来维护这一个最小值，对于每一个位置$bfs$查询四个方向，维护一个$vis$数组避免重复访问，更新$ans$ 为外围高度减去，内层高度。\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int trapRainWater(vector<vector<int>>& heightMap) {\n        int d[] = {-1, 0, 1, 0 ,-1};\n        int n = heightMap.size(), m = heightMap[0].size();\n        struct node {int x, y, w;};\n        struct cmp {\n            bool operator()(const node &a, const node & b) {\n                return a.w > b.w;\n            }\n        };\n        priority_queue<node, vector<node>, cmp> pq;\n        vector<vector<bool>> vis(n, vector<bool>(m));\n        //cout << \"zhangly\" << endl;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1) {\n                    pq.push({i, j, heightMap[i][j]});\n                    vis[i][j] = 1;\n                } else {\n                    vis[i][j] = 0;\n                }\n            }\n        }\n        // for(;!pq.empty();) {\n        //     auto[i, j, w] = pq.top();pq.pop();\n        //     cout << i << ' ' << j << \" \" << w << endl;\n        // }\n        //cout << \"aaa\" << endl;\n        int ans = 0;\n        while(!pq.empty()) {\n            auto[x, y, w] = pq.top();\n            pq.pop();\n            ans += w - heightMap[x][y];\n            // cout << x << ' ' << y << ' ' << w << endl;\n            // cout << ans << endl;\n            for(int i = 0; i < 4; i++) {\n                int nx = x + d[i];\n                int ny = y + d[i + 1];\n                //cout << x << ' ' << y << endl;\n                //cout << nx << ' '  << ny << endl;\n                //cout << i << ' '<< i + 1 << endl;\n                if(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny]) {\n                    pq.push({nx, ny, max(w, heightMap[nx][ny])});\n                    vis[nx][ny] = 1;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n这里详细说一下这一句：\n\n```cpp\npq.push({nx, ny, max(w, heightMap[nx][ny])});\n```\n\n为什么取$max$不是$min$ ?这样想，假设当前柱子高度为$h_{cur}$，当前内层高度为$h_{in}$，外层高度为$h_{out}$，有：$h_{in} < h_{cur} < h_{out}$，如果去$min$，那么$h_{in}$ 只能接$h_{cur} - h_{in}$，实际上，能接$h_{out} - h_{in}$，所以这里的最小值代表是优先处理的顺序，我们要顶着最小先处理。\n\n\n\n\n\ncnm!!!!!!!!调破防了，nm，tm调了一下午超时nb，\n\nhttps://leetcode.cn/problems/word-ladder-ii/\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<string, unordered_set<string>> mp;\n    vector<string> path;\n    vector<vector<string>> ans;\n    unordered_set<string> st;\n    unordered_map<string, int> dis;\n    //unordered_map<string, bool> vis;\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        for(auto s : wordList) {\n            st.insert(s);\n        }\n        //cout << (st.find(endWord) == st.end()) << endl;\n        if(st.find(endWord) == st.end()) {\n            return {};\n        } else {\n            //cout << bfs(beginWord, endWord) << endl; \n            if(bfs(beginWord, endWord)) {\n                dfs(beginWord, endWord);\n                return ans;\n            } else {\n                return {};\n            }\n        }\n        return ans;\n    }\n    bool bfs(string s1, string s2) {\n        unordered_set<string> vis;\n        queue<string> q;\n        q.push(s1);\n        vis.insert(s1);\n        dis[s1] = 0;\n        bool flag = 0;\n        while(!q.empty()) {\n            int sz = q.size();\n            unordered_set<string> vis_cur;\n            for(int i = 0; i < sz; i++) {\n                string cur = q.front();\n                q.pop();\n                //int step = dis[cur];\n                for(int i = 0; i < cur.size(); i++) {\n                    string nxt = cur;\n                    for(char ch = 'a'; ch <= 'z'; ch++) {\n                        if(nxt[i] == ch) continue;\n                        nxt[i] = ch;\n                        if(st.find(nxt) == st.end()) continue;\n                        if(vis.find(nxt) != vis.end()) continue;\n                        mp[cur].insert(nxt);\n                        if(nxt == s2) flag = 1;\n                        if(!vis_cur.count(nxt)) {\n                            vis_cur.insert(nxt);\n                            dis[nxt] = dis[cur] + 1;\n                            q.push(nxt); \n                        }\n                    }\n                }\n            }\n            for(auto x : vis_cur) vis.insert(x);\n            if(flag) break;\n        }\n        return flag;\n    }\n    void dfs(string s1, string s2) {\n        path.push_back(s1);\n        if(s1 == s2) ans.push_back(path);\n        else {\n            for(auto &x : mp[s1]) {\n                if(dis[s1] = dis[x] + 1)\n                dfs(x, s2);\n            }\n        }\n        path.pop_back();\n    } \n}; \n```\n\n\n\n**折半搜索**，又叫**双向广搜**，适用于全局搜索会T但问题有可以分解为左右两个部分。\n\n[P4799 [CEOI 2015] 世界冰球锦标赛 (Day2) - 洛谷](https://www.luogu.com.cn/problem/P4799)\n\n经典例题，一眼数据量无法$dp$，全局搜索会T，考虑折半搜索，题目要求方案数\n\n$dfs$分别查找左右两部分计算出花费，因为花费不超$w$，所以$s_l + s_r <= w$，移项，$w-s_r>=s_l$，所以只要在$s_l$中查找小于等于$s_l$的最大值，显然顺序不影响，所以排序，二分加速即可\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 45;\nll n, m, v[N], ans;\nvector<ll> a;\nvector<ll> b;\nvoid dfs(ll l, ll r, vector<ll> &a, ll sum) {\n    if(sum > m) return;\n    if(l > r) {a.push_back(sum);return;}\n    dfs(l + 1, r, a, sum + v[l]);\n    dfs(l + 1, r, a, sum);\n}\nint main() {\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) cin >> v[i];\n    int mid = n >> 1;\n    dfs(1, mid, a, 0);\n    dfs(mid + 1, n, b, 0);\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    for(int i = 0; i < b.size(); i++) {\n        ans += upper_bound(a.begin(), a.end(), m - b[i]) - a.begin();\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n# **双倍快乐**\n\n[P3067 [USACO12OPEN] Balanced Cow Subsets G - 洛谷](https://www.luogu.com.cn/problem/P3067)\n\n选一些数组成集合$A \\in S$，使$sum_a=sum_b(a \\in A，b = \\overline{A})$\n\n看一眼数据，全局爆搜会T，折半查找。\n\n为什么可以折半查找？下面给出简单证明\n\n将$S$分为集合$A,B$，$sum_A，sum_B$为分别为$A,B$集合累加和，则有$sum_A == sum_B$\n\n设a，b分别为加入a，b集合的元素，sum_A - a == sum_B - b，移项，sum_A + b == sum_B + a，元素顺序不影响，所以我们可以在dfs过程中分块，再merge。\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nchar buf[1 << 20], *p1 = buf, *p2 = buf;\ninline char getc() {\n    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++;\n}\n\ntemplate<typename T>\ninline void read(T &x) {\n    x = 0; T f = 1;\n    char c = getc();\n    while (c < '0' || c > '9') {\n        if (c == '-') f = -1;\n        c = getc();\n    }\n    while (c >= '0' && c <= '9') {\n        x = x * 10 + c - '0';\n        c = getc();\n    }\n    x *= f;\n}\nchar obuf[1 << 20], *p = obuf;\ninline void pc(char c) {\n    *p++ = c;\n}\n\ntemplate<typename T>\ninline void write(T x) {\n    static char num[40];\n    int len = 0;\n    if (x < 0) pc('-'), x = -x;\n    if (x == 0) pc('0');\n    while (x) {\n        num[len++] = x % 10 + '0';\n        x /= 10;\n    }\n    while (len--) pc(num[len]);\n}\n\ninline void write_bool(bool x) {\n    if(x) {\n        pc('t');pc('r');pc('u');pc('e');\n    } else {\n        pc('f');pc('a');pc('l');pc('s');pc('e');\n    }\n}\ninline void write_ok(bool x) {\n    if(x) {\n        pc('Y');pc('E');pc('S');\n    } else {\n        pc('N');pc('O');\n    }\n}\ninline void flush() {\n    fwrite(obuf, p - obuf, 1, stdout);\n}\nconst int N = 21;\nll n, v[N], tot, s, ans[1 << N];\nvector<ll> path[1 << N];\nmap<ll, ll> mp;\nvoid dfs1(ll l, ll r, ll val, ll sta) {\n    if(l > r) {\n        if(mp[val] == 0) mp[val] = ++tot;\n        path[mp[val]].push_back(sta);\n        return;\n    }\n    dfs1(l + 1, r, val, sta);\n    dfs1(l + 1, r, val - v[l], sta | (1 << (l - 1)));\n    dfs1(l + 1, r, val + v[l], sta | (1 << (l - 1)));\n}\nvoid dfs2(ll l, ll r, ll val, ll sta) {\n    if(l > r) {\n        auto x = mp[val];//这里要存起来，不然会T\n        if(x != 0)\n        for(int i = 0; i < path[x].size(); i++) ans[path[x][i] | sta] = 1;\n        return;\n    }\n    dfs2(l + 1, r, val, sta);\n    dfs2(l + 1, r, val + v[l], sta | (1 << (l - 1)));\n    dfs2(l + 1, r, val - v[l], sta | (1 << (l - 1)));\n}\nint main() {\n    read(n);\n    for(int i = 1; i <= n; i++) read(v[i]);\n    ll mid = n >> 1;\n    dfs1(1, mid, 0, 0);\n    //cerr << \"aaa\" << endl;\n    dfs2(mid + 1, n, 0, 0);\n    for(int i = 1; i <= 1 << n; i++) {\n        s += ans[i];\n    }\n    write(s);\n    flush();\n    return 0;\n}\n\n```\n\n[SPOJ.com - Problem AKBAR](https://www.spoj.com/problems/AKBAR/)\n\n题目求一个bfs能否占领所有的点，广搜即可。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6 + 5;\nint n, m, r, t, a, b, kk, ss, vis[N];\nstruct node\n{\n    int k, s, idx;\n};\nvector<int> g[N];\nvoid slove()\n{\n    cin >> n >> r >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        g[i].clear();\n        vis[i] = 0;\n    }\n    for (int i = 1; i <= r; i++)\n    {\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    queue<node> q;\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> kk >> ss;\n        if (vis[kk] != 0)\n        {\n            cout << \"No\" << endl;\n            return;\n        }\n        vis[kk] = i;\n        q.push({kk, ss, i});\n    }\n    while (!q.empty())\n    {\n        int x = q.front().k;\n        int y = q.front().s;\n        int z = q.front().idx;\n        q.pop();\n        if (y == 0)\n            continue;\n        for (auto v : g[x])\n        {\n            if (vis[v] == 0)\n            {\n                vis[v] = z;\n                q.push({v, y - 1, z});//层数限制不能超过y层\n            }\n            else if (vis[v] != z)\n            {\n                cout << \"No\" << endl;\n                return;\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        if (vis[i] == 0)\n        {\n            cout << \"No\" << endl;\n            return;\n        }\n    cout << \"Yes\" << endl;\n}\nint main()\n{\n    cin >> t;\n    while (t--)\n        slove();\n    return 0;\n}\n```\n\n[Sphere Online Judge (SPOJ) - Submit a solution](https://www.spoj.com/submit/NAKANJ/)\n\n简单$bfs$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint t, vis[9][9];\nint dx[] = {0, 1, 2, -1, -2, 2, 1, -2, -1};\nint dy[] = {0, -2, -1, -2, -1, 1, 2, 1, 2};\nqueue<pair<int, int>> q;\nvoid slove() {\n    //q.clear();\n    q = queue<pair<int, int>>();//队列不清空，WA后两行泪\n    string s1 = \"\", s2 = \"\";\n    cin >> s1 >> s2;\n    memset(vis, 0, sizeof(vis));\n    int y1 = s1[0] - 'a' + 1, x1 = s1[1] - '0';\n    int y2 = s2[0] - 'a' + 1, x2 = s2[1] - '0';\n    //cerr << x1 << ' ' << y1  << endl;\n    //cerr << x2 << ' ' << y2 << endl;\n    q.push({x1, y1});\n    vis[x1][y1] = 1;\n    int ans = 0;\n    while(!q.empty()) {\n        int sz = q.size();\n        for(int i = 1; i <= sz; i++) {\n            int x = q.front().first;\n            int y = q.front().second;\n            //cerr << x << ' ' << y << endl; 调试不注释，T后两行泪\n            q.pop();\n            if(x == x2 && y == y2) {cout << ans << endl; return;}\n            for(int i = 1; i <= 8; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(!vis[nx][ny] && nx >= 1 && nx <= 8 && ny >= 1 && ny <= 8) {\n                    vis[nx][ny] = 1;\n                    q.push({nx, ny});\n                    //cerr << nx << ' ' << ny << endl;\n                }\n            }\n        }\n        ans++;\n    }\n}\nint main() {\n    cin >> t;\n    while(t--) slove();\n    return 0;\n}\n```\n\n$01bfs$即可\n\n[Dev Skill - Holloween Party](https://web.archive.org/web/20200930162803/http://www.devskill.com/CodingProblems/ViewProblem/60)\n\n````cpp\n","tags":["-BFS"],"categories":["Algorithm"]},{"title":"DAG + DP","url":"/2025/06/08/DAG/","content":"\nhttps://acm.timus.ru/problem.aspx?space=1&num=2034\n\n也算是折腾了很久吧，开始是维护了$dis_r,dis_s,dis_f$数组分别表示最大值结果$WA$了，恐怕没有那么简单~~对我来说~~，这道题，求最小值的最大值，对于这类题目，构建一个$DAG$，记录$s$到$f$所有可呢的最短路径，即当且仅当：$dis_s[u] + dis_f[v] + 1 = dis_s[f]$时，我们把$u,v$连边，拓扑排序（$DAG$图往往天然保持拓扑序），$dp$，这里重点说一下状态转移方程，定义$dp[u]$为商队所走的最短路径上距离$r$的所有最小值的点中最大值，考虑：\n\n初始化$dp[u] = -inf$表示不可达\n\n$dp[s] = dis_r[s]$\n\n转移：\n设$x$为$s$到$u$的一条最短路中距离$r$最小的点，$v$是有$u$拓展出来的点，则：\n\n                                        $dis_r[x] = min(dis[v], dis[x])$\n\n对于每个拓展出来的点$v$就有，最大值：\n\n                                        $dp[v] = max(dp[v],min(dis[x])_{(all \\:path)})$\n\n而$dp[u]$已经帮我们更新好了，所以：\n\n                                        $dp[v] = max(dp[v], min(dp[u], dis_r[v])$\n\n最终返回$dp[f]$\n\n时间复杂度：$O(N + M)$节点数量加边的数量。\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>    //这也太丑了吧.......\n#define inf 1 << 30        //其实将就能看.....\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint n, m, s, f, r, a, b, dis_s[N], dis_f[N], dis_r[N], vis_s[N], vis_f[N], vis_r[N], dp[N], in[N];\nvector<int> g[N << 1]; \nvector<int> dag[N];\nint main() {\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) {\n        dis_s[i] = inf;\n        dis_f[i] = inf;\n        dis_r[i] = inf;\n        vis_s[i] = 0;\n        vis_f[i] = 0;\n        vis_r[i] = 0;\n    }\n    for(int i = 1; i <= m; i++) {\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    cin >> s >> f >> r;\n    dis_s[s] = 0;\n    dis_f[f] = 0;\n    dis_r[r] = 0;\n    vis_s[s] = 1;\n    vis_f[f] = 1;\n    vis_r[r] = 1;\n    queue<int> q1;\n    queue<int> q2;\n    queue<int> q3;\n    q1.push(s);\n    q2.push(f);\n    q3.push(r);\n    while(!q1.empty()) {\n        int u1 = q1.front(); q1.pop();\n        for(auto v : g[u1]) {\n            if(dis_s[v] > dis_s[u1] + 1) {\n                dis_s[v] = dis_s[u1] + 1;\n                q1.push(v);\n                vis_s[v] = 1;\n            }\n        }\n    }\n    while(!q2.empty()) {\n        int u2 = q2.front(); q2.pop();\n        for(auto v : g[u2]) {\n            if(dis_f[v] > dis_f[u2] + 1) {\n                dis_f[v] = dis_f[u2] + 1;\n                q2.push(v);\n                vis_f[v] = 1; \n            }\n        }\n    }\n    while(!q3.empty()) {\n        int u3 = q3.front(); q3.pop();\n        for(auto v : g[u3]) {\n            if(dis_r[v] > dis_r[u3] + 1) {\n                dis_r[v] = dis_r[u3] + 1;\n                q3.push(v);\n                vis_r[v] = 1; \n            }\n        }\n    }\n    for(int u = 1; u <= n; u++) {\n        for(auto v : g[u]) {\n            if(dis_s[u] + 1 + dis_f[v] == dis_s[f]) {\n                dag[u].push_back(v);\n                in[v]++;\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++) dp[i] = -inf;\n    dp[s] = dis_r[s];\n    queue<int> q;\n    for(int i = 1; i <= n; i++) {\n        if(in[i] == 0) q.push(i);\n    }\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n        if(dp[u] == -inf) continue;\n        for(auto v : dag[u]) {\n            dp[v] = max(dp[v], min(dp[u], dis_r[v]));\n            if(--in[v] == 0) q.push(v);\n        }\n    }\n    cout << dp[f] << endl;\n    return 0;\n}\n```\n","tags":["-ShortestPath"],"categories":["Algorithm"]},{"title":"SPIKES - Spiky Mazes","url":"/2025/06/07/a/","content":"\n[SPOJ.com - Problem SPIKES](https://www.spoj.com/problems/SPIKES/)\n\n一个不可达卡我一上午，............................唉，算了\n\n深搜版本：\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\nusing namespace std;\n\nconst int N = 45;\nint n, m, s;\nint dx[] = {0, 0, 0, -1, 1};\nint dy[] = {0, -1, 1, 0, 0};\nchar g[N][N];\nint vis[N][N];\nvector<int> ans;\nint main() {\n    cin >> n >> m >> s;\n    ans.clear();\n    int x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n    for(int i = 1; i <= n; i++)\n    for(int j = 1; j <= m; j++) \n    g[i][j] = 0;\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= m; j++) {\n            cin >> g[i][j];\n            if(g[i][j] == '@') {\n                x1 = i, y1 = j;\n            }\n            if(g[i][j] == 'x') {\n                x2 = i, y2 = j;\n            }\n            vis[i][j] = 0;\n            //cerr << g[i][j] << ' ';  \n        }\n        //cerr << endl;\n    }\n    function<void(int, int, int)> dfs = [&](int x, int y, int s) {\n        if(x == x2 && y == y2) {\n            ans.push_back(s);\n            return;\n        }\n        for(int i = 1; i <= 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx <= n && nx >= 1 && ny <= m && ny >= 1) {\n                if(g[nx][ny] != '#' && !vis[nx][ny]) {\n                    //cerr << x << ' ' << y << ' ' << endl;\n                    //cerr  << s << ' ' << ns << ' ' << endl;\n                    vis[nx][ny] = 1;\n                    dfs(nx, ny, s + (g[nx][ny] == 's'));\n                    vis[nx][ny] = 0;\n                }\n            }\n        }\n    };\n    dfs(x1, y1, 0);\n    int mn = inf;\n    //cerr << x1 << ' ' << y1;\n    for(auto a : ans) mn = min(mn, a);\n    //cerr << mn << ' ';\n    if((mn != inf) && (mn * 2 <= s)) cout << \"SUCCESS\" << endl;//要特判不可达！！！！\n    else cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}\n```\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\nusing namespace std;\n\nchar c;\nint n, m, s;\nconst int N = 45;\nstruct e {int x, y, w;};\nint dis[N][N], dx[] = {0, 0, 0, -1, 1}, dy[] = {0, -1, 1, 0, 0};\nchar g[N][N];  \nint main() {\n    cin >> n >> m >> s;\n    deque<e> d;\n    int x1 = 0, y1 = 0;\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= m; j++) {\n            cin >> c;\n            g[i][j] = c;\n            dis[i][j] = inf;\n            if(c == '@') {\n                //cerr << i << ' ' << endl;\n                d.push_front({i, j, 0});\n                dis[i][j] = 0;\n            }\n            if(c == 'x') {\n                x1 = i, y1 = j;\n            }\n        }\n    }\n    bool flag = 0;\n    while(!d.empty()) {\n        int sz = d.size();\n        for(int i = 1; i <= sz; i++) {\n            int x = d.front().x;\n            int y = d.front().y;\n            int w = d.front().w;\n            d.pop_front();\n            if(x == x1 && y == y1) {\n                //cerr << dis[x][y] << endl;\n                //return 0;\n                break;\n            }\n            for(int i = 1; i <= 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(nx <= n && nx >= 0 && ny <= m && ny >= 0) {\n                    if(g[nx][ny] == '#') continue;\n                    int ww = g[nx][ny] == 's';\n                    if(dis[nx][ny] > dis[x][y] + ww) {\n                        dis[nx][ny] = dis[x][y] + ww;\n                        if(ww == 0) d.push_back({nx, ny, ww});\n                        else d.push_front({nx, ny, ww});\n                    }\n                }\n            }\n        }\n    }\n    // for(int i = 1; i <= n; i++) {\n    //     for(int j = 1; j <= m; j++) {\n    //         cerr << dis[i][j] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n    if(dis[x1][y1] != inf && dis[x1][y1] * 2 <= s) cout << \"SUCCESS\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}\n```\n","categories":["Algorithm"]}]