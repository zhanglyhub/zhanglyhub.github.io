[{"title":"BFS","url":"/2025/06/08/bfs/","content":"\n一般都为多源$bfs$，队列实现，每次处理一层(我更喜欢叫它如下弹出行为重复$size$遍)\n\nLeetCode-1162地图分析\n\nhttps://leetcode.cn/problems/as-far-from-land-as-possible/description/\n\n几乎可以说是模板题，要求最远的距离，其实就是在求$bfs$了多少层返回层数即可。\n\n------------------------------------------------------------------------------------------------------------------------------\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int d[] = {-1, 0, 1, 0, -1};//d数组的用法\n        int sea = 0;\n         queue<pair<int, int>> q;\n        bool vis[101][101] = {};\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == 1) {\n                    q.push({i, j});\n                    vis[i][j] = 1;\n                } else {\n                    vis[i][j] = 0;\n                    sea++;\n                }\n            }\n        }\n        if(sea == 0 || sea == n * n) return -1;\n        int level = -1;        //注意level初始化为-1，默认从第0层开始\n        while(!q.empty()) {\n            level++;\n            //cout << level << ' ';\n            int sz = q.size();\n            for(int i = 0; i < sz; i++) {\n                int x = q.front().first;\n                int y = q.front().second;\n                q.pop();\n                for(int i = 0; i < 4; i++) {\n                    int nx = x + d[i];\n                    int ny = y + d[i + 1];\n                    if(nx < n && nx >= 0 && ny >= 0 && ny < n && !vis[nx][ny] && grid[nx][ny] == 0) {\n                        vis[nx][ny] = 1;\n                        //cout << nx << ' ' << ny << endl;\n                        q.push({nx, ny});\n                    }\n                }\n            }\n        }\n        return level;\n    }\n};\n```\n\n\n\nLeetCode-691贴纸拼词\n\nhttps://leetcode.cn/problems/stickers-to-spell-word/description/\n\n这道题有多种解法，动态规划也能解（好吧其实是我没学），$bfs$ 的解法挺妙的，我们可以这样考虑，每次使用这些贴纸可以搞定$target$多少字符，自然智慧，显然字符的顺序是不影响答案的，所以我们可以先排序，注意这里的剪枝，考虑我们迟早要干掉首字符的，莫不如顶着首字符先干掉，再去干掉后面的字符，接下来就是$bfs\\:+del$函数的设计，具体看$code$\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minStickers(vector<string>& stickers, string target) {\n        int n = stickers.size();\n        sort(target.begin(), target.end());\n        vector<string> g[401];\n        for(auto str : stickers) {\n            sort(str.begin(), str.end());\n            for(int i = 0; i < str.size(); i++) {\n                if(i == 0 || str[i] != str[i - 1]) {\n                    g[str[i] - 'a'].push_back(str);//避免重复加入\n                }\n            }\n        }\n        unordered_map<string, bool> vis;\n        queue<string> q;\n        vis[target] = 1;\n        q.push(target);\n        int level = 1;\n        while(!q.empty()) {\n            int sz= q.size();\n            for(int i = 0; i < sz; i++) {\n                string cur = q.front();\n                q.pop();\n                for(string s : g[cur[0] - 'a']) {\n                    string nxt = del(cur, s);\n                    sort(nxt.begin(), nxt.end());\n                    //cout << nxt << ' ';\n                    if(nxt == \"\") return level;\n                    else if(!vis[nxt]) {\n                        vis[nxt] = 1;\n                        q.push(nxt);\n                    }\n                }\n            }\n            level++;\n        }\n        return -1;\n    }\n    string del(string cur, string s) {\n        vector<int> cnt1 (26, 0);//词频统计\n        vector<int> cnt2 (26, 0);\n        string ans = \"\";\n        for(int i = 0; i < cur.size(); i++) {\n            cnt1[cur[i] - 'a']++;\n        }\n        for(int i = 0; i < s.size(); i++) {\n            cnt2[s[i] - 'a']++;\n        }\n        for(int i = 0; i < 26; i++ ) {\n            int times = cnt1[i] - cnt2[i];\n            if(times > 0) {\n                ans += string(times, i + 'a');\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n# bfs变种之01bfs\n\n顾名思义，就是图中所有边的权值只有01两种，01bfs我们使用双端队列，将权值为1的从尾部加入，权值为0的从头部加入。\n\nLeetCode-2290\n\nhttps://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/\n\n板题\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCost(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<int> dis(n * m, inf);\n        dis[0] = 0;\n        int dx[] = {0, -1, 0, 1, 0};\n        int dy[] = {0, 0, 1, 0, -1};\n        deque<pair<int, int>> dq;\n        dq.push_front({0, 0});\n        while(!dq.empty()) {\n            int x = dq.front().first;\n            int y = dq.front().second;\n            int idx = x * m + y;\n            for(int i = 1; i <= 4; i++) {\n                int nx = x + d[i];\n                int ny = y + d[i];\n                int nidx = x * m + y;\n                if(nx < n && ny < m && nx >= 0 && ny >= 0)  {\n                    int w = grid[nx][ny] == i;\n                    if(dis[nidx] > dis[idx] + w) {\n                        dis[nidx] = dis[idx] + w;\n                        if(w == 0) dq.push_front({nx, ny};)\n                        else dq.push_back({nx, ny});\n                    }\n                }\n            }\n        }\n        return dis[n * m - 1];\n    }\n};\n```\n\n这里有个技巧建立二维到一维的映射公式：$x * m + y$\n\n\n\nLeetCode-1368\n\nhttps://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description/\n\n其实也是简单01bfs啦，要看明白这个转化，箭头和我要去的方向一样就是0，否则就是1\n\n***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 1 << 30\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCost(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<int> dis(n * m, inf);\n        dis[0] = 0;\n        int dx[] = {0, 0, 0, 1, -1};\n        int dy[] = {0, 1, -1, 0, 0};\n        deque<pair<int, int>> dq;\n        //dq.clear();\n        dq.push_front({0, 0});\n        while(!dq.empty()) {\n            int x = dq.front().first;\n            int y = dq.front().second;\n            dq.pop_front();\n            int idx = x * m + y;\n            if (idx == n * m - 1) return dis[idx];//安全返回\n            for(int i = 1; i <= 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];;\n                int nidx = nx * m + ny;\n                if(nx < n && ny < m && nx >= 0 && ny >= 0)  {\n                    int w = (grid[x][y] == i) ? 0 : 1;\n                    if(dis[nidx] > dis[idx] + w) {\n                        dis[nidx] = dis[idx] + w;//这里要注意提前返回的时机不能在这里，因为只有当前节点\"真正\"从队列中弹出时才能返回（更新）\n                        if(w == 0) dq.push_front({nx, ny});\n                        else dq.push_back({nx, ny});\n                    }\n                }\n            }\n        }\n        // for(int i = 0; i < dis.size(); i++) {\n        //     cout << dis[i] << ' ';\n        // }\n        return dis[n * m - 1];\n    }\n};\n```\n\nLeetCode-接雨水II\n\nhttps://leetcode.cn/problems/trapping-rain-water-ii/submissions/634317688/\n\n越界也是没谁了，方向数组写错也是没谁了。悼念........................................\n\n经典的堆和$bfs$的结合，和一维接雨水类似，首先，考虑外围一层，显然不能接雨水，而我内层势必依赖于外层的最小高度所以有：$max_{inh}<=min_{outh}$，不妨拓展开来，对于每一个柱子，考虑四个方向必然也满足这个条件，所以我们可以用堆来维护这一个最小值，对于每一个位置$bfs$查询四个方向，维护一个$vis$数组避免重复访问，更新$ans$ 为外围高度减去，内层高度。\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int trapRainWater(vector<vector<int>>& heightMap) {\n        int d[] = {-1, 0, 1, 0 ,-1};\n        int n = heightMap.size(), m = heightMap[0].size();\n        struct node {int x, y, w;};\n        struct cmp {\n            bool operator()(const node &a, const node & b) {\n                return a.w > b.w;\n            }\n        };\n        priority_queue<node, vector<node>, cmp> pq;\n        vector<vector<bool>> vis(n, vector<bool>(m));\n        //cout << \"zhangly\" << endl;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1) {\n                    pq.push({i, j, heightMap[i][j]});\n                    vis[i][j] = 1;\n                } else {\n                    vis[i][j] = 0;\n                }\n            }\n        }\n        // for(;!pq.empty();) {\n        //     auto[i, j, w] = pq.top();pq.pop();\n        //     cout << i << ' ' << j << \" \" << w << endl;\n        // }\n        //cout << \"aaa\" << endl;\n        int ans = 0;\n        while(!pq.empty()) {\n            auto[x, y, w] = pq.top();\n            pq.pop();\n            ans += w - heightMap[x][y];\n            // cout << x << ' ' << y << ' ' << w << endl;\n            // cout << ans << endl;\n            for(int i = 0; i < 4; i++) {\n                int nx = x + d[i];\n                int ny = y + d[i + 1];\n                //cout << x << ' ' << y << endl;\n                //cout << nx << ' '  << ny << endl;\n                //cout << i << ' '<< i + 1 << endl;\n                if(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny]) {\n                    pq.push({nx, ny, max(w, heightMap[nx][ny])});\n                    vis[nx][ny] = 1;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n这里详细说一下这一句：\n\n```cpp\npq.push({nx, ny, max(w, heightMap[nx][ny])});\n```\n\n为什么取$max$不是$min$ ?这样想，假设当前柱子高度为$h_{cur}$，当前内层高度为$h_{in}$，外层高度为$h_{out}$，有：$h_{in} < h_{cur} < h_{out}$，如果去$min$，那么$h_{in}$ 只能接$h_{cur} - h_{in}$，实际上，能接$h_{out} - h_{in}$，所以这里的最小值代表是优先处理的顺序，我们要顶着最小先处理。\n\n\n\n\n\ncnm!!!!!!!!调破防了，nm，tm调了一下午超时nb，\n\nhttps://leetcode.cn/problems/word-ladder-ii/\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<string, unordered_set<string>> mp;\n    vector<string> path;\n    vector<vector<string>> ans;\n    unordered_set<string> st;\n    unordered_map<string, int> dis;\n    //unordered_map<string, bool> vis;\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        for(auto s : wordList) {\n            st.insert(s);\n        }\n        //cout << (st.find(endWord) == st.end()) << endl;\n        if(st.find(endWord) == st.end()) {\n            return {};\n        } else {\n            //cout << bfs(beginWord, endWord) << endl; \n            if(bfs(beginWord, endWord)) {\n                dfs(beginWord, endWord);\n                return ans;\n            } else {\n                return {};\n            }\n        }\n        return ans;\n    }\n    bool bfs(string s1, string s2) {\n        unordered_set<string> vis;\n        queue<string> q;\n        q.push(s1);\n        vis.insert(s1);\n        dis[s1] = 0;\n        bool flag = 0;\n        while(!q.empty()) {\n            int sz = q.size();\n            unordered_set<string> vis_cur;\n            for(int i = 0; i < sz; i++) {\n                string cur = q.front();\n                q.pop();\n                //int step = dis[cur];\n                for(int i = 0; i < cur.size(); i++) {\n                    string nxt = cur;\n                    for(char ch = 'a'; ch <= 'z'; ch++) {\n                        if(nxt[i] == ch) continue;\n                        nxt[i] = ch;\n                        if(st.find(nxt) == st.end()) continue;\n                        if(vis.find(nxt) != vis.end()) continue;\n                        mp[cur].insert(nxt);\n                        if(nxt == s2) flag = 1;\n                        if(!vis_cur.count(nxt)) {\n                            vis_cur.insert(nxt);\n                            dis[nxt] = dis[cur] + 1;\n                            q.push(nxt); \n                        }\n                    }\n                }\n            }\n            for(auto x : vis_cur) vis.insert(x);\n            if(flag) break;\n        }\n        return flag;\n    }\n    void dfs(string s1, string s2) {\n        path.push_back(s1);\n        if(s1 == s2) ans.push_back(path);\n        else {\n            for(auto &x : mp[s1]) {\n                if(dis[s1] = dis[x] + 1)\n                dfs(x, s2);\n            }\n        }\n        path.pop_back();\n    } \n}; \n```\n\n\n\n**折半搜索**，又叫**双向广搜**，适用于全局搜索会T但问题有可以分解为左右两个部分。\n\n[P4799 [CEOI 2015] 世界冰球锦标赛 (Day2) - 洛谷](https://www.luogu.com.cn/problem/P4799)\n\n经典例题，一眼数据量无法$dp$，全局搜索会T，考虑折半搜索，题目要求方案数\n\n$dfs$分别查找左右两部分计算出花费，因为花费不超$w$，所以$s_l + s_r <= w$，移项，$w-s_r>=s_l$，所以只要在$s_l$中查找小于等于$s_l$的最大值，显然顺序不影响，所以排序，二分加速即可\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 45;\nll n, m, v[N], ans;\nvector<ll> a;\nvector<ll> b;\nvoid dfs(ll l, ll r, vector<ll> &a, ll sum) {\n    if(sum > m) return;\n    if(l > r) {a.push_back(sum);return;}\n    dfs(l + 1, r, a, sum + v[l]);\n    dfs(l + 1, r, a, sum);\n}\nint main() {\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) cin >> v[i];\n    int mid = n >> 1;\n    dfs(1, mid, a, 0);\n    dfs(mid + 1, n, b, 0);\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    for(int i = 0; i < b.size(); i++) {\n        ans += upper_bound(a.begin(), a.end(), m - b[i]) - a.begin();\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n# **双倍快乐**\n\n[P3067 [USACO12OPEN] Balanced Cow Subsets G - 洛谷](https://www.luogu.com.cn/problem/P3067)\n\n选一些数组成集合$A \\in S$，使$sum_a=sum_b(a \\in A，b = \\overline{A})$\n\n看一眼数据，全局爆搜会T，折半查找。\n\n为什么可以折半查找？下面给出简单证明\n\n将$S$分为集合$A,B$，$sum_A，sum_B$为分别为$A,B$集合累加和，则有$sum_A == sum_B$\n\n设a，b分别为加入a，b集合的元素，sum_A - a == sum_B - b，移项，sum_A + b == sum_B + a，元素顺序不影响，所以我们可以在dfs过程中分块，再merge。\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nchar buf[1 << 20], *p1 = buf, *p2 = buf;\ninline char getc() {\n    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++;\n}\n\ntemplate<typename T>\ninline void read(T &x) {\n    x = 0; T f = 1;\n    char c = getc();\n    while (c < '0' || c > '9') {\n        if (c == '-') f = -1;\n        c = getc();\n    }\n    while (c >= '0' && c <= '9') {\n        x = x * 10 + c - '0';\n        c = getc();\n    }\n    x *= f;\n}\nchar obuf[1 << 20], *p = obuf;\ninline void pc(char c) {\n    *p++ = c;\n}\n\ntemplate<typename T>\ninline void write(T x) {\n    static char num[40];\n    int len = 0;\n    if (x < 0) pc('-'), x = -x;\n    if (x == 0) pc('0');\n    while (x) {\n        num[len++] = x % 10 + '0';\n        x /= 10;\n    }\n    while (len--) pc(num[len]);\n}\n\ninline void write_bool(bool x) {\n    if(x) {\n        pc('t');pc('r');pc('u');pc('e');\n    } else {\n        pc('f');pc('a');pc('l');pc('s');pc('e');\n    }\n}\ninline void write_ok(bool x) {\n    if(x) {\n        pc('Y');pc('E');pc('S');\n    } else {\n        pc('N');pc('O');\n    }\n}\ninline void flush() {\n    fwrite(obuf, p - obuf, 1, stdout);\n}\nconst int N = 21;\nll n, v[N], tot, s, ans[1 << N];\nvector<ll> path[1 << N];\nmap<ll, ll> mp;\nvoid dfs1(ll l, ll r, ll val, ll sta) {\n    if(l > r) {\n        if(mp[val] == 0) mp[val] = ++tot;\n        path[mp[val]].push_back(sta);\n        return;\n    }\n    dfs1(l + 1, r, val, sta);\n    dfs1(l + 1, r, val - v[l], sta | (1 << (l - 1)));\n    dfs1(l + 1, r, val + v[l], sta | (1 << (l - 1)));\n}\nvoid dfs2(ll l, ll r, ll val, ll sta) {\n    if(l > r) {\n        auto x = mp[val];//这里要存起来，不然会T\n        if(x != 0)\n        for(int i = 0; i < path[x].size(); i++) ans[path[x][i] | sta] = 1;\n        return;\n    }\n    dfs2(l + 1, r, val, sta);\n    dfs2(l + 1, r, val + v[l], sta | (1 << (l - 1)));\n    dfs2(l + 1, r, val - v[l], sta | (1 << (l - 1)));\n}\nint main() {\n    read(n);\n    for(int i = 1; i <= n; i++) read(v[i]);\n    ll mid = n >> 1;\n    dfs1(1, mid, 0, 0);\n    //cerr << \"aaa\" << endl;\n    dfs2(mid + 1, n, 0, 0);\n    for(int i = 1; i <= 1 << n; i++) {\n        s += ans[i];\n    }\n    write(s);\n    flush();\n    return 0;\n}\n\n```\n\n[SPOJ.com - Problem AKBAR](https://www.spoj.com/problems/AKBAR/)\n\n题目求一个bfs能否占领所有的点，广搜即可。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6 + 5;\nint n, m, r, t, a, b, kk, ss, vis[N];\nstruct node\n{\n    int k, s, idx;\n};\nvector<int> g[N];\nvoid slove()\n{\n    cin >> n >> r >> m;\n    for (int i = 1; i <= n; i++)\n    {\n        g[i].clear();\n        vis[i] = 0;\n    }\n    for (int i = 1; i <= r; i++)\n    {\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    queue<node> q;\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> kk >> ss;\n        if (vis[kk] != 0)\n        {\n            cout << \"No\" << endl;\n            return;\n        }\n        vis[kk] = i;\n        q.push({kk, ss, i});\n    }\n    while (!q.empty())\n    {\n        int x = q.front().k;\n        int y = q.front().s;\n        int z = q.front().idx;\n        q.pop();\n        if (y == 0)\n            continue;\n        for (auto v : g[x])\n        {\n            if (vis[v] == 0)\n            {\n                vis[v] = z;\n                q.push({v, y - 1, z});//层数限制不能超过y层\n            }\n            else if (vis[v] != z)\n            {\n                cout << \"No\" << endl;\n                return;\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        if (vis[i] == 0)\n        {\n            cout << \"No\" << endl;\n            return;\n        }\n    cout << \"Yes\" << endl;\n}\nint main()\n{\n    cin >> t;\n    while (t--)\n        slove();\n    return 0;\n}\n```\n\n[Sphere Online Judge (SPOJ) - Submit a solution](https://www.spoj.com/submit/NAKANJ/)\n\n简单$bfs$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint t, vis[9][9];\nint dx[] = {0, 1, 2, -1, -2, 2, 1, -2, -1};\nint dy[] = {0, -2, -1, -2, -1, 1, 2, 1, 2};\nqueue<pair<int, int>> q;\nvoid slove() {\n    //q.clear();\n    q = queue<pair<int, int>>();//队列不清空，WA后两行泪\n    string s1 = \"\", s2 = \"\";\n    cin >> s1 >> s2;\n    memset(vis, 0, sizeof(vis));\n    int y1 = s1[0] - 'a' + 1, x1 = s1[1] - '0';\n    int y2 = s2[0] - 'a' + 1, x2 = s2[1] - '0';\n    //cerr << x1 << ' ' << y1  << endl;\n    //cerr << x2 << ' ' << y2 << endl;\n    q.push({x1, y1});\n    vis[x1][y1] = 1;\n    int ans = 0;\n    while(!q.empty()) {\n        int sz = q.size();\n        for(int i = 1; i <= sz; i++) {\n            int x = q.front().first;\n            int y = q.front().second;\n            //cerr << x << ' ' << y << endl; 调试不注释，T后两行泪\n            q.pop();\n            if(x == x2 && y == y2) {cout << ans << endl; return;}\n            for(int i = 1; i <= 8; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(!vis[nx][ny] && nx >= 1 && nx <= 8 && ny >= 1 && ny <= 8) {\n                    vis[nx][ny] = 1;\n                    q.push({nx, ny});\n                    //cerr << nx << ' ' << ny << endl;\n                }\n            }\n        }\n        ans++;\n    }\n}\nint main() {\n    cin >> t;\n    while(t--) slove();\n    return 0;\n}\n```\n","tags":["-BFS"],"categories":["Algorithm"]},{"title":"DAG + DP","url":"/2025/06/08/DAG/","content":"\n也算是折腾了很久吧，开始是维护了$dis_r,dis_s,dis_f$数组分别表示最大值结果$WA$了，恐怕没有那么简单~~对我来说~~，这道题，求最小值的最大值，对于这类题目，构建一个$DAG$，记录$s$到$f$所有可呢的最短路径，即当且仅当：$dis_s[u] + dis_f[v] + 1 = dis_s[f]$时，我们把$u,v$连边，拓扑排序（$DAG$图往往天然保持拓扑序），$dp$，这里重点说一下状态转移方程，定义$dp[u]$为商队所走的最短路径上距离$r$的所有最小值的点中最大值，考虑：\n\n初始化$dp[u] = -inf$表示不可达\n\n$dp[s] = dis_r[s]$\n\n转移：\n设$x$为$s$到$u$的一条最短路中距离$r$最小的点，$v$是有$u$拓展出来的点，则：\n\n                                        $dis_r[x] = min(dis[v], dis[x])$\n\n对于每个拓展出来的点$v$就有，最大值：\n\n                                        $dp[v] = max(dp[v],min(dis[x])_{(all \\:path)})$\n\n而$dp[u]$已经帮我们更新好了，所以：\n\n                                        $dp[v] = max(dp[v], min(dp[u], dis_r[v])$\n\n最终返回$dp[f]$\n\n时间复杂度：$O(N + M)$节点数量加边的数量。\n\n# ***ACcode***\n\n```cpp\n#include<bits/stdc++.h>    //这也太丑了吧.......\n#define inf 1 << 30        //其实将就能看.....\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint n, m, s, f, r, a, b, dis_s[N], dis_f[N], dis_r[N], vis_s[N], vis_f[N], vis_r[N], dp[N], in[N];\nvector<int> g[N << 1]; \nvector<int> dag[N];\nint main() {\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) {\n        dis_s[i] = inf;\n        dis_f[i] = inf;\n        dis_r[i] = inf;\n        vis_s[i] = 0;\n        vis_f[i] = 0;\n        vis_r[i] = 0;\n    }\n    for(int i = 1; i <= m; i++) {\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    cin >> s >> f >> r;\n    dis_s[s] = 0;\n    dis_f[f] = 0;\n    dis_r[r] = 0;\n    vis_s[s] = 1;\n    vis_f[f] = 1;\n    vis_r[r] = 1;\n    queue<int> q1;\n    queue<int> q2;\n    queue<int> q3;\n    q1.push(s);\n    q2.push(f);\n    q3.push(r);\n    while(!q1.empty()) {\n        int u1 = q1.front(); q1.pop();\n        for(auto v : g[u1]) {\n            if(dis_s[v] > dis_s[u1] + 1) {\n                dis_s[v] = dis_s[u1] + 1;\n                q1.push(v);\n                vis_s[v] = 1;\n            }\n        }\n    }\n    while(!q2.empty()) {\n        int u2 = q2.front(); q2.pop();\n        for(auto v : g[u2]) {\n            if(dis_f[v] > dis_f[u2] + 1) {\n                dis_f[v] = dis_f[u2] + 1;\n                q2.push(v);\n                vis_f[v] = 1; \n            }\n        }\n    }\n    while(!q3.empty()) {\n        int u3 = q3.front(); q3.pop();\n        for(auto v : g[u3]) {\n            if(dis_r[v] > dis_r[u3] + 1) {\n                dis_r[v] = dis_r[u3] + 1;\n                q3.push(v);\n                vis_r[v] = 1; \n            }\n        }\n    }\n    for(int u = 1; u <= n; u++) {\n        for(auto v : g[u]) {\n            if(dis_s[u] + 1 + dis_f[v] == dis_s[f]) {\n                dag[u].push_back(v);\n                in[v]++;\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++) dp[i] = -inf;\n    dp[s] = dis_r[s];\n    queue<int> q;\n    for(int i = 1; i <= n; i++) {\n        if(in[i] == 0) q.push(i);\n    }\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n        if(dp[u] == -inf) continue;\n        for(auto v : dag[u]) {\n            dp[v] = max(dp[v], min(dp[u], dis_r[v]));\n            if(--in[v] == 0) q.push(v);\n        }\n    }\n    cout << dp[f] << endl;\n    return 0;\n}\n```\n","tags":["-ShortestPath"],"categories":["Algorithm"]}]